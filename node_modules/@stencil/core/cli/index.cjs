/*!
 Stencil CLI (CommonJS) v4.17.0 | MIT Licensed | https://stenciljs.com
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cli/index.ts
var cli_exports = {};
__export(cli_exports, {
  BOOLEAN_CLI_FLAGS: () => BOOLEAN_CLI_FLAGS,
  parseFlags: () => parseFlags,
  run: () => run,
  runTask: () => runTask
});
module.exports = __toCommonJS(cli_exports);

// src/cli/config-flags.ts
var BOOLEAN_CLI_FLAGS = [
  "build",
  "cache",
  "checkVersion",
  "ci",
  "compare",
  "debug",
  "dev",
  "devtools",
  "docs",
  "e2e",
  "es5",
  "esm",
  "help",
  "log",
  "open",
  "prerender",
  "prerenderExternal",
  "prod",
  "profile",
  "serviceWorker",
  "screenshot",
  "serve",
  "skipNodeCheck",
  "spec",
  "ssr",
  "stats",
  "updateScreenshot",
  "verbose",
  "version",
  "watch",
  // JEST CLI OPTIONS
  "all",
  "automock",
  "bail",
  // 'cache', Stencil already supports this argument
  "changedFilesWithAncestor",
  // 'ci', Stencil already supports this argument
  "clearCache",
  "clearMocks",
  "collectCoverage",
  "color",
  "colors",
  "coverage",
  // 'debug', Stencil already supports this argument
  "detectLeaks",
  "detectOpenHandles",
  "errorOnDeprecated",
  "expand",
  "findRelatedTests",
  "forceExit",
  "init",
  "injectGlobals",
  "json",
  "lastCommit",
  "listTests",
  "logHeapUsage",
  "noStackTrace",
  "notify",
  "onlyChanged",
  "onlyFailures",
  "passWithNoTests",
  "resetMocks",
  "resetModules",
  "restoreMocks",
  "runInBand",
  "runTestsByPath",
  "showConfig",
  "silent",
  "skipFilter",
  "testLocationInResults",
  "updateSnapshot",
  "useStderr",
  // 'verbose', Stencil already supports this argument
  // 'version', Stencil already supports this argument
  // 'watch', Stencil already supports this argument
  "watchAll",
  "watchman"
];
var NUMBER_CLI_FLAGS = [
  "port",
  // JEST CLI ARGS
  "maxConcurrency",
  "testTimeout"
];
var STRING_CLI_FLAGS = [
  "address",
  "config",
  "docsApi",
  "docsJson",
  "emulate",
  "root",
  "screenshotConnector",
  // JEST CLI ARGS
  "cacheDirectory",
  "changedSince",
  "collectCoverageFrom",
  // 'config', Stencil already supports this argument
  "coverageDirectory",
  "coverageThreshold",
  "env",
  "filter",
  "globalSetup",
  "globalTeardown",
  "globals",
  "haste",
  "moduleNameMapper",
  "notifyMode",
  "outputFile",
  "preset",
  "prettierPath",
  "resolver",
  "rootDir",
  "runner",
  "testEnvironment",
  "testEnvironmentOptions",
  "testFailureExitCode",
  "testNamePattern",
  "testResultsProcessor",
  "testRunner",
  "testSequencer",
  "testURL",
  "timers",
  "transform"
];
var STRING_ARRAY_CLI_FLAGS = [
  "collectCoverageOnlyFrom",
  "coveragePathIgnorePatterns",
  "coverageReporters",
  "moduleDirectories",
  "moduleFileExtensions",
  "modulePathIgnorePatterns",
  "modulePaths",
  "projects",
  "reporters",
  "roots",
  "selectProjects",
  "setupFiles",
  "setupFilesAfterEnv",
  "snapshotSerializers",
  "testMatch",
  "testPathIgnorePatterns",
  "testPathPattern",
  "testRegex",
  "transformIgnorePatterns",
  "unmockedModulePathPatterns",
  "watchPathIgnorePatterns"
];
var STRING_NUMBER_CLI_FLAGS = ["maxWorkers"];
var BOOLEAN_STRING_CLI_FLAGS = [
  /**
   * `headless` is an argument passed through to Puppeteer (which is passed to Chrome) for end-to-end testing.
   * Prior to Chrome v112, `headless` was treated like a boolean flag. Starting with Chrome v112, 'new' is an accepted
   * option to support Chrome's new headless mode. In order to support this option in Stencil, both the boolean and
   * string versions of the flag must be accepted.
   *
   * {@see https://developer.chrome.com/articles/new-headless/}
   */
  "headless"
];
var LOG_LEVEL_CLI_FLAGS = ["logLevel"];
var CLI_FLAG_ALIASES = {
  c: "config",
  h: "help",
  p: "port",
  v: "version",
  // JEST SPECIFIC CLI FLAGS
  // these are defined in
  // https://github.com/facebook/jest/blob/4156f86/packages/jest-cli/src/args.ts
  b: "bail",
  e: "expand",
  f: "onlyFailures",
  i: "runInBand",
  o: "onlyChanged",
  t: "testNamePattern",
  u: "updateSnapshot",
  w: "maxWorkers"
};
var CLI_FLAG_REGEX = new RegExp(`^-[chpvbewofitu]{1}$`);
var createConfigFlags = (init = {}) => {
  const flags = {
    task: null,
    args: [],
    knownArgs: [],
    unknownArgs: [],
    ...init
  };
  return flags;
};

// src/utils/constants.ts
var DIST_HYDRATE_SCRIPT = "dist-hydrate-script";
var DOCS_CUSTOM = "docs-custom";
var DOCS_JSON = "docs-json";
var DOCS_README = "docs-readme";
var DOCS_VSCODE = "docs-vscode";
var WWW = "www";

// src/utils/helpers.ts
var dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
var toCamelCase = (str) => {
  const pascalCase = dashToPascalCase(str);
  return pascalCase.charAt(0).toLowerCase() + pascalCase.slice(1);
};
var isFunction = (v) => typeof v === "function";
var isString = (v) => typeof v === "string";

// src/utils/message-utils.ts
var buildError = (diagnostics) => {
  const diagnostic = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    relFilePath: void 0,
    absFilePath: void 0,
    lines: []
  };
  if (diagnostics) {
    diagnostics.push(diagnostic);
  }
  return diagnostic;
};
var catchError = (diagnostics, err2, msg) => {
  const diagnostic = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    lines: []
  };
  if (isString(msg)) {
    diagnostic.messageText = msg.length ? msg : "UNKNOWN ERROR";
  } else if (err2 != null) {
    if (err2.stack != null) {
      diagnostic.messageText = err2.stack.toString();
    } else {
      if (err2.message != null) {
        diagnostic.messageText = err2.message.length ? err2.message : "UNKNOWN ERROR";
      } else {
        diagnostic.messageText = err2.toString();
      }
    }
  }
  if (diagnostics != null && !shouldIgnoreError(diagnostic.messageText)) {
    diagnostics.push(diagnostic);
  }
  return diagnostic;
};
var hasError = (diagnostics) => {
  if (diagnostics == null || diagnostics.length === 0) {
    return false;
  }
  return diagnostics.some((d) => d.level === "error" && d.type !== "runtime");
};
var shouldIgnoreError = (msg) => {
  return msg === TASK_CANCELED_MSG;
};
var TASK_CANCELED_MSG = `task canceled`;

// src/utils/path.ts
var normalizePath = (path, relativize = true) => {
  if (typeof path !== "string") {
    throw new Error(`invalid path to normalize`);
  }
  path = normalizeSlashes(path.trim());
  const components = pathComponents(path, getRootLength(path));
  const reducedComponents = reducePathComponents(components);
  const rootPart = reducedComponents[0];
  const secondPart = reducedComponents[1];
  const normalized = rootPart + reducedComponents.slice(1).join("/");
  if (normalized === "") {
    return ".";
  }
  if (rootPart === "" && secondPart && path.includes("/") && !secondPart.startsWith(".") && !secondPart.startsWith("@") && relativize) {
    return "./" + normalized;
  }
  return normalized;
};
var normalizeSlashes = (path) => path.replace(backslashRegExp, "/");
var altDirectorySeparator = "\\";
var urlSchemeSeparator = "://";
var backslashRegExp = /\\/g;
var reducePathComponents = (components) => {
  if (!Array.isArray(components) || components.length === 0) {
    return [];
  }
  const reduced = [components[0]];
  for (let i = 1; i < components.length; i++) {
    const component = components[i];
    if (!component)
      continue;
    if (component === ".")
      continue;
    if (component === "..") {
      if (reduced.length > 1) {
        if (reduced[reduced.length - 1] !== "..") {
          reduced.pop();
          continue;
        }
      } else if (reduced[0])
        continue;
    }
    reduced.push(component);
  }
  return reduced;
};
var getRootLength = (path) => {
  const rootLength = getEncodedRootLength(path);
  return rootLength < 0 ? ~rootLength : rootLength;
};
var getEncodedRootLength = (path) => {
  if (!path)
    return 0;
  const ch0 = path.charCodeAt(0);
  if (ch0 === 47 /* slash */ || ch0 === 92 /* backslash */) {
    if (path.charCodeAt(1) !== ch0)
      return 1;
    const p1 = path.indexOf(ch0 === 47 /* slash */ ? "/" : altDirectorySeparator, 2);
    if (p1 < 0)
      return path.length;
    return p1 + 1;
  }
  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* colon */) {
    const ch2 = path.charCodeAt(2);
    if (ch2 === 47 /* slash */ || ch2 === 92 /* backslash */)
      return 3;
    if (path.length === 2)
      return 2;
  }
  const schemeEnd = path.indexOf(urlSchemeSeparator);
  if (schemeEnd !== -1) {
    const authorityStart = schemeEnd + urlSchemeSeparator.length;
    const authorityEnd = path.indexOf("/", authorityStart);
    if (authorityEnd !== -1) {
      const scheme = path.slice(0, schemeEnd);
      const authority = path.slice(authorityStart, authorityEnd);
      if (scheme === "file" && (authority === "" || authority === "localhost") && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
        if (volumeSeparatorEnd !== -1) {
          if (path.charCodeAt(volumeSeparatorEnd) === 47 /* slash */) {
            return ~(volumeSeparatorEnd + 1);
          }
          if (volumeSeparatorEnd === path.length) {
            return ~volumeSeparatorEnd;
          }
        }
      }
      return ~(authorityEnd + 1);
    }
    return ~path.length;
  }
  return 0;
};
var isVolumeCharacter = (charCode) => charCode >= 97 /* a */ && charCode <= 122 /* z */ || charCode >= 65 /* A */ && charCode <= 90 /* Z */;
var getFileUrlVolumeSeparatorEnd = (url, start) => {
  const ch0 = url.charCodeAt(start);
  if (ch0 === 58 /* colon */)
    return start + 1;
  if (ch0 === 37 /* percent */ && url.charCodeAt(start + 1) === 51 /* _3 */) {
    const ch2 = url.charCodeAt(start + 2);
    if (ch2 === 97 /* a */ || ch2 === 65 /* A */)
      return start + 3;
  }
  return -1;
};
var pathComponents = (path, rootLength) => {
  const root = path.substring(0, rootLength);
  const rest = path.substring(rootLength).split("/");
  const restLen = rest.length;
  if (restLen > 0 && !rest[restLen - 1]) {
    rest.pop();
  }
  return [root, ...rest];
};

// src/utils/output-target.ts
var isOutputTargetHydrate = (o) => o.type === DIST_HYDRATE_SCRIPT;
var isOutputTargetDocs = (o) => o.type === DOCS_README || o.type === DOCS_JSON || o.type === DOCS_CUSTOM || o.type === DOCS_VSCODE;

// src/utils/result.ts
var result_exports = {};
__export(result_exports, {
  err: () => err,
  map: () => map,
  ok: () => ok,
  unwrap: () => unwrap,
  unwrapErr: () => unwrapErr
});
var ok = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map(result, fn) {
  if (result.isOk) {
    const val = fn(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
var unwrap = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};

// src/utils/util.ts
var readOnlyArrayHasStringMember = (readOnlyArray, maybeMember) => readOnlyArray.includes(maybeMember);

// src/utils/validation.ts
var validateComponentTag = (tag) => {
  if (typeof tag !== "string") {
    return `Tag "${tag}" must be a string type`;
  }
  if (tag !== tag.trim()) {
    return `Tag can not contain white spaces`;
  }
  if (tag !== tag.toLowerCase()) {
    return `Tag can not contain upper case characters`;
  }
  if (tag.length === 0) {
    return `Received empty tag value`;
  }
  if (tag.indexOf(" ") > -1) {
    return `"${tag}" tag cannot contain a space`;
  }
  if (tag.indexOf(",") > -1) {
    return `"${tag}" tag cannot be used for multiple tags`;
  }
  const invalidChars = tag.replace(/\w|-/g, "");
  if (invalidChars !== "") {
    return `"${tag}" tag contains invalid characters: ${invalidChars}`;
  }
  if (tag.indexOf("-") === -1) {
    return `"${tag}" tag must contain a dash (-) to work as a valid web component`;
  }
  if (tag.indexOf("--") > -1) {
    return `"${tag}" tag cannot contain multiple dashes (--) next to each other`;
  }
  if (tag.indexOf("-") === 0) {
    return `"${tag}" tag cannot start with a dash (-)`;
  }
  if (tag.lastIndexOf("-") === tag.length - 1) {
    return `"${tag}" tag cannot end with a dash (-)`;
  }
  return void 0;
};

// src/declarations/stencil-public-compiler.ts
var LOG_LEVELS = ["debug", "info", "warn", "error"];

// src/cli/parse-flags.ts
var parseFlags = (args) => {
  const flags = createConfigFlags();
  flags.args = Array.isArray(args) ? args.slice() : [];
  if (flags.args.length > 0 && flags.args[0] && !flags.args[0].startsWith("-")) {
    flags.task = flags.args[0];
    parseArgs(flags, args.slice(1));
  } else {
    parseArgs(flags, flags.args);
  }
  if (flags.task != null) {
    const i = flags.args.indexOf(flags.task);
    if (i > -1) {
      flags.args.splice(i, 1);
    }
  }
  return flags;
};
var parseArgs = (flags, args) => {
  const argsCopy = args.concat();
  while (argsCopy.length > 0) {
    parseCLITerm(flags, argsCopy);
  }
};
var parseCLITerm = (flags, args) => {
  const arg = args.shift();
  if (arg === void 0)
    return;
  const isNegatedBoolean = !readOnlyArrayHasStringMember(BOOLEAN_CLI_FLAGS, normalizeFlagName(arg)) && readOnlyArrayHasStringMember(BOOLEAN_CLI_FLAGS, normalizeNegativeFlagName(arg));
  const isNegatedBooleanOrString = !readOnlyArrayHasStringMember(BOOLEAN_STRING_CLI_FLAGS, normalizeFlagName(arg)) && readOnlyArrayHasStringMember(BOOLEAN_STRING_CLI_FLAGS, normalizeNegativeFlagName(arg));
  if (arg.startsWith("--") && arg.includes("=")) {
    const [originalArg, value] = parseEqualsArg(arg);
    setCLIArg(flags, arg.split("=")[0], normalizeFlagName(originalArg), value);
  } else if (arg.startsWith("-") && arg.includes("=")) {
    const [originalArg, value] = parseEqualsArg(arg);
    setCLIArg(flags, desugarRawAlias(originalArg), normalizeFlagName(originalArg), value);
  } else if (CLI_FLAG_REGEX.test(arg)) {
    setCLIArg(flags, desugarRawAlias(arg), normalizeFlagName(arg), parseCLIValue(args));
  } else if (arg.startsWith("--no-") && arg.length > "--no-".length) {
    const normalized = normalizeNegativeFlagName(arg);
    setCLIArg(flags, arg, normalized, "");
  } else if (arg.startsWith("--no") && (isNegatedBoolean || isNegatedBooleanOrString)) {
    setCLIArg(flags, arg, normalizeNegativeFlagName(arg), "");
  } else if (arg.startsWith("--") && arg.length > "--".length) {
    setCLIArg(flags, arg, normalizeFlagName(arg), parseCLIValue(args));
  } else {
    flags.unknownArgs.push(arg);
  }
};
var normalizeNegativeFlagName = (flagName) => {
  const trimmed = flagName.replace(/^--no[-]?/, "");
  return normalizeFlagName(trimmed.charAt(0).toLowerCase() + trimmed.slice(1));
};
var normalizeFlagName = (flagName) => {
  const trimmed = flagName.replace(/^-+/, "");
  return trimmed.includes("-") ? toCamelCase(trimmed) : trimmed;
};
var setCLIArg = (flags, rawArg, normalizedArg, value) => {
  normalizedArg = desugarAlias(normalizedArg);
  if (readOnlyArrayHasStringMember(BOOLEAN_CLI_FLAGS, normalizedArg)) {
    const parsed = typeof value === "string" ? (
      // check if the value is `'true'`
      value === "true"
    ) : (
      // no value was supplied, default to true
      true
    );
    flags[normalizedArg] = parsed;
    flags.knownArgs.push(rawArg);
    if (typeof value === "string" && value !== "") {
      flags.knownArgs.push(value);
    }
  } else if (readOnlyArrayHasStringMember(STRING_CLI_FLAGS, normalizedArg)) {
    if (typeof value === "string") {
      flags[normalizedArg] = value;
      flags.knownArgs.push(rawArg);
      flags.knownArgs.push(value);
    } else {
      throwCLIParsingError(rawArg, "expected a string argument but received nothing");
    }
  } else if (readOnlyArrayHasStringMember(STRING_ARRAY_CLI_FLAGS, normalizedArg)) {
    if (typeof value === "string") {
      if (!Array.isArray(flags[normalizedArg])) {
        flags[normalizedArg] = [];
      }
      const targetArray = flags[normalizedArg];
      if (Array.isArray(targetArray)) {
        targetArray.push(value);
        flags.knownArgs.push(rawArg);
        flags.knownArgs.push(value);
      }
    } else {
      throwCLIParsingError(rawArg, "expected a string argument but received nothing");
    }
  } else if (readOnlyArrayHasStringMember(NUMBER_CLI_FLAGS, normalizedArg)) {
    if (typeof value === "string") {
      const parsed = parseInt(value, 10);
      if (isNaN(parsed)) {
        throwNumberParsingError(rawArg, value);
      } else {
        flags[normalizedArg] = parsed;
        flags.knownArgs.push(rawArg);
        flags.knownArgs.push(value);
      }
    } else {
      throwCLIParsingError(rawArg, "expected a number argument but received nothing");
    }
  } else if (readOnlyArrayHasStringMember(STRING_NUMBER_CLI_FLAGS, normalizedArg)) {
    if (typeof value === "string") {
      if (CLI_ARG_STRING_REGEX.test(value)) {
        flags[normalizedArg] = value;
      } else {
        const parsed = Number(value);
        if (isNaN(parsed)) {
          throwNumberParsingError(rawArg, value);
        } else {
          flags[normalizedArg] = parsed;
        }
      }
      flags.knownArgs.push(rawArg);
      flags.knownArgs.push(value);
    } else {
      throwCLIParsingError(rawArg, "expected a string or a number but received nothing");
    }
  } else if (readOnlyArrayHasStringMember(BOOLEAN_STRING_CLI_FLAGS, normalizedArg)) {
    const derivedValue = typeof value === "string" ? value ? value : false : true;
    flags[normalizedArg] = derivedValue;
    flags.knownArgs.push(rawArg);
    if (typeof derivedValue === "string" && derivedValue) {
      flags.knownArgs.push(derivedValue);
    }
  } else if (readOnlyArrayHasStringMember(LOG_LEVEL_CLI_FLAGS, normalizedArg)) {
    if (typeof value === "string") {
      if (isLogLevel(value)) {
        flags[normalizedArg] = value;
        flags.knownArgs.push(rawArg);
        flags.knownArgs.push(value);
      } else {
        throwCLIParsingError(rawArg, `expected to receive a valid log level but received "${String(value)}"`);
      }
    } else {
      throwCLIParsingError(rawArg, "expected to receive a valid log level but received nothing");
    }
  } else {
    flags.unknownArgs.push(rawArg);
    if (typeof value === "string") {
      flags.unknownArgs.push(value);
    }
  }
};
var CLI_ARG_STRING_REGEX = /[^\d\.Ee\+\-]+/g;
var Empty = Symbol("Empty");
var parseCLIValue = (args) => {
  if (args[0] === void 0) {
    return Empty;
  }
  if (!args[0].startsWith("-")) {
    const value = args.shift();
    if (typeof value === "string") {
      return value;
    }
  }
  return Empty;
};
var parseEqualsArg = (arg) => {
  const [originalArg, ...splitSections] = arg.split("=");
  const value = splitSections.join("=");
  return [originalArg, value === "" ? Empty : value];
};
var isLogLevel = (maybeLogLevel) => readOnlyArrayHasStringMember(LOG_LEVELS, maybeLogLevel);
var throwCLIParsingError = (flag, message) => {
  throw new Error(`when parsing CLI flag "${flag}": ${message}`);
};
var throwNumberParsingError = (flag, value) => {
  throwCLIParsingError(flag, `expected a number but received "${value}"`);
};
var desugarAlias = (maybeAlias) => {
  const possiblyDesugared = CLI_FLAG_ALIASES[maybeAlias];
  if (typeof possiblyDesugared === "string") {
    return possiblyDesugared;
  }
  return maybeAlias;
};
var desugarRawAlias = (rawAlias) => "--" + desugarAlias(normalizeFlagName(rawAlias));

// src/cli/find-config.ts
var findConfig = async (opts) => {
  const sys = opts.sys;
  const cwd = sys.getCurrentDirectory();
  const rootDir = normalizePath(cwd);
  let configPath = opts.configPath;
  if (isString(configPath)) {
    if (!sys.platformPath.isAbsolute(configPath)) {
      configPath = normalizePath(sys.platformPath.join(cwd, configPath));
    } else {
      configPath = normalizePath(opts.configPath);
    }
  } else {
    configPath = rootDir;
  }
  const results = {
    configPath,
    rootDir: normalizePath(cwd)
  };
  const stat = await sys.stat(configPath);
  if (stat.error) {
    const diagnostics = [];
    const diagnostic = buildError(diagnostics);
    diagnostic.absFilePath = configPath;
    diagnostic.header = `Invalid config path`;
    diagnostic.messageText = `Config path "${configPath}" not found`;
    return result_exports.err(diagnostics);
  }
  if (stat.isFile) {
    results.configPath = configPath;
    results.rootDir = sys.platformPath.dirname(configPath);
  } else if (stat.isDirectory) {
    for (const configName of ["stencil.config.ts", "stencil.config.js"]) {
      const testConfigFilePath = sys.platformPath.join(configPath, configName);
      const stat2 = await sys.stat(testConfigFilePath);
      if (stat2.isFile) {
        results.configPath = testConfigFilePath;
        results.rootDir = sys.platformPath.dirname(testConfigFilePath);
        break;
      }
    }
  }
  return result_exports.ok(results);
};

// src/cli/load-compiler.ts
var loadCoreCompiler = async (sys) => {
  const compilerMod = await sys.dynamicImport(sys.getCompilerExecutingPath());
  if (globalThis.stencil) {
    return globalThis.stencil;
  } else {
    globalThis.stencil = compilerMod;
    return compilerMod;
  }
};

// src/cli/logs.ts
var startupLog = (logger, task) => {
  if (task === "info" || task === "serve" || task === "version") {
    return;
  }
  logger.info(logger.cyan(`@stencil/core`));
};
var startupLogVersion = (logger, task, coreCompiler) => {
  if (task === "info" || task === "serve" || task === "version") {
    return;
  }
  const isDevBuild = coreCompiler.version.includes("-dev.");
  let startupMsg;
  if (isDevBuild) {
    startupMsg = logger.yellow(`[LOCAL DEV] v${coreCompiler.version}`);
  } else {
    startupMsg = logger.cyan(`v${coreCompiler.version}`);
  }
  startupMsg += logger.emoji(" " + coreCompiler.vermoji);
  logger.info(startupMsg);
};
var loadedCompilerLog = (sys, logger, flags, coreCompiler) => {
  const sysDetails = sys.details;
  const runtimeInfo = `${sys.name} ${sys.version}`;
  const platformInfo = sysDetails ? `${sysDetails.platform}, ${sysDetails.cpuModel}` : `Unknown Platform, Unknown CPU Model`;
  const statsInfo = sysDetails ? `cpus: ${sys.hardwareConcurrency}, freemem: ${Math.round(
    sysDetails.freemem() / 1e6
  )}MB, totalmem: ${Math.round(sysDetails.totalmem / 1e6)}MB` : "Unknown CPU Core Count, Unknown Memory";
  if (logger.getLevel() === "debug") {
    logger.debug(runtimeInfo);
    logger.debug(platformInfo);
    logger.debug(statsInfo);
    logger.debug(`compiler: ${sys.getCompilerExecutingPath()}`);
    logger.debug(`build: ${coreCompiler.buildId}`);
  } else if (flags.ci) {
    logger.info(runtimeInfo);
    logger.info(platformInfo);
    logger.info(statsInfo);
  }
};
var startupCompilerLog = (coreCompiler, config) => {
  if (config.suppressLogs === true) {
    return;
  }
  const { logger } = config;
  const isDebug = logger.getLevel() === "debug";
  const isPrerelease = coreCompiler.version.includes("-");
  const isDevBuild = coreCompiler.version.includes("-dev.");
  if (isPrerelease && !isDevBuild) {
    logger.warn(
      logger.yellow(
        `This is a prerelease build, undocumented changes might happen at any time. Technical support is not available for prereleases, but any assistance testing is appreciated.`
      )
    );
  }
  if (config.devMode && !isDebug) {
    if (config.buildEs5) {
      logger.warn(
        `Generating ES5 during development is a very task expensive, initial and incremental builds will be much slower. Drop the '--es5' flag and use a modern browser for development.`
      );
    }
    if (!config.enableCache) {
      logger.warn(`Disabling cache during development will slow down incremental builds.`);
    }
  }
};

// src/cli/check-version.ts
var startCheckVersion = async (config, currentVersion) => {
  if (config.devMode && !config.flags.ci && !currentVersion.includes("-dev.") && isFunction(config.sys.checkVersion)) {
    return config.sys.checkVersion(config.logger, currentVersion);
  }
  return null;
};
var printCheckVersionResults = async (versionChecker) => {
  if (versionChecker) {
    const checkVersionResults = await versionChecker;
    if (isFunction(checkVersionResults)) {
      checkVersionResults();
    }
  }
};

// src/cli/task-prerender.ts
var taskPrerender = async (coreCompiler, config) => {
  startupCompilerLog(coreCompiler, config);
  const hydrateAppFilePath = config.flags.unknownArgs[0];
  if (typeof hydrateAppFilePath !== "string") {
    config.logger.error(`Missing hydrate app script path`);
    return config.sys.exit(1);
  }
  const srcIndexHtmlPath = config.srcIndexHtml;
  const diagnostics = await runPrerenderTask(coreCompiler, config, hydrateAppFilePath, null, srcIndexHtmlPath);
  config.logger.printDiagnostics(diagnostics);
  if (diagnostics.some((d) => d.level === "error")) {
    return config.sys.exit(1);
  }
};
var runPrerenderTask = async (coreCompiler, config, hydrateAppFilePath, componentGraph, srcIndexHtmlPath) => {
  const diagnostics = [];
  try {
    const prerenderer = await coreCompiler.createPrerenderer(config);
    const results = await prerenderer.start({
      hydrateAppFilePath,
      componentGraph,
      srcIndexHtmlPath
    });
    diagnostics.push(...results.diagnostics);
  } catch (e) {
    catchError(diagnostics, e);
  }
  return diagnostics;
};

// src/cli/task-watch.ts
var taskWatch = async (coreCompiler, config) => {
  let devServer = null;
  let exitCode = 0;
  try {
    startupCompilerLog(coreCompiler, config);
    const versionChecker = startCheckVersion(config, coreCompiler.version);
    const compiler = await coreCompiler.createCompiler(config);
    const watcher = await compiler.createWatcher();
    if (config.flags.serve) {
      const devServerPath = config.sys.getDevServerExecutingPath();
      const { start } = await config.sys.dynamicImport(devServerPath);
      devServer = await start(config.devServer, config.logger, watcher);
    }
    config.sys.onProcessInterrupt(() => {
      config.logger.debug(`close watch`);
      compiler && compiler.destroy();
    });
    const rmVersionCheckerLog = watcher.on("buildFinish", async () => {
      rmVersionCheckerLog();
      printCheckVersionResults(versionChecker);
    });
    if (devServer) {
      const rmDevServerLog = watcher.on("buildFinish", () => {
        var _a;
        rmDevServerLog();
        const url = (_a = devServer == null ? void 0 : devServer.browserUrl) != null ? _a : "UNKNOWN URL";
        config.logger.info(`${config.logger.cyan(url)}
`);
      });
    }
    const closeResults = await watcher.start();
    if (closeResults.exitCode > 0) {
      exitCode = closeResults.exitCode;
    }
  } catch (e) {
    exitCode = 1;
    config.logger.error(e);
  }
  if (devServer) {
    await devServer.close();
  }
  if (exitCode > 0) {
    return config.sys.exit(exitCode);
  }
};

// src/cli/telemetry/helpers.ts
var tryFn = async (fn, ...args) => {
  try {
    return await fn(...args);
  } catch {
  }
  return null;
};
var isInteractive = (sys, flags, object) => {
  const terminalInfo = object || Object.freeze({
    tty: sys.isTTY() ? true : false,
    ci: ["CI", "BUILD_ID", "BUILD_NUMBER", "BITBUCKET_COMMIT", "CODEBUILD_BUILD_ARN"].filter(
      (v) => {
        var _a;
        return !!((_a = sys.getEnvironmentVar) == null ? void 0 : _a.call(sys, v));
      }
    ).length > 0 || !!flags.ci
  });
  return terminalInfo.tty && !terminalInfo.ci;
};
var UUID_REGEX = new RegExp(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i);
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
async function readJson(sys, path) {
  const file = await sys.readFile(path);
  return !!file && JSON.parse(file);
}
function hasDebug(flags) {
  return !!flags.debug;
}
function hasVerbose(flags) {
  return !!flags.verbose && hasDebug(flags);
}

// src/cli/ionic-config.ts
var isTest = () => process.env.JEST_WORKER_ID !== void 0;
var defaultConfig = (sys) => sys.resolvePath(`${sys.homeDir()}/.ionic/${isTest() ? "tmp-config.json" : "config.json"}`);
var defaultConfigDirectory = (sys) => sys.resolvePath(`${sys.homeDir()}/.ionic`);
async function readConfig(sys) {
  let config = await readJson(sys, defaultConfig(sys));
  if (!config) {
    config = {
      "tokens.telemetry": uuidv4(),
      "telemetry.stencil": true
    };
    await writeConfig(sys, config);
  } else if (!config["tokens.telemetry"] || !UUID_REGEX.test(config["tokens.telemetry"])) {
    const newUuid = uuidv4();
    await writeConfig(sys, { ...config, "tokens.telemetry": newUuid });
    config["tokens.telemetry"] = newUuid;
  }
  return config;
}
async function writeConfig(sys, config) {
  let result = false;
  try {
    await sys.createDir(defaultConfigDirectory(sys), { recursive: true });
    await sys.writeFile(defaultConfig(sys), JSON.stringify(config, null, 2));
    result = true;
  } catch (error) {
    console.error(`Stencil Telemetry: couldn't write configuration file to ${defaultConfig(sys)} - ${error}.`);
  }
  return result;
}
async function updateConfig(sys, newOptions) {
  const config = await readConfig(sys);
  return await writeConfig(sys, Object.assign(config, newOptions));
}

// src/cli/telemetry/shouldTrack.ts
async function shouldTrack(config, sys, ci) {
  return !ci && isInteractive(sys, config.flags) && await checkTelemetry(sys);
}

// src/cli/telemetry/telemetry.ts
async function telemetryBuildFinishedAction(sys, config, coreCompiler, result) {
  const tracking = await shouldTrack(config, sys, !!config.flags.ci);
  if (!tracking) {
    return;
  }
  const component_count = result.componentGraph ? Object.keys(result.componentGraph).length : void 0;
  const data = await prepareData(coreCompiler, config, sys, result.duration, component_count);
  await sendMetric(sys, config, "stencil_cli_command", data);
  config.logger.debug(`${config.logger.blue("Telemetry")}: ${config.logger.gray(JSON.stringify(data))}`);
}
async function telemetryAction(sys, config, coreCompiler, action) {
  const tracking = await shouldTrack(config, sys, !!config.flags.ci);
  let duration = void 0;
  let error;
  if (action) {
    const start = /* @__PURE__ */ new Date();
    try {
      await action();
    } catch (e) {
      error = e;
    }
    const end = /* @__PURE__ */ new Date();
    duration = end.getTime() - start.getTime();
  }
  if (!tracking || config.flags.task == "build" && !config.flags.args.includes("--watch")) {
    return;
  }
  const data = await prepareData(coreCompiler, config, sys, duration);
  await sendMetric(sys, config, "stencil_cli_command", data);
  config.logger.debug(`${config.logger.blue("Telemetry")}: ${config.logger.gray(JSON.stringify(data))}`);
  if (error) {
    throw error;
  }
}
function hasAppTarget(config) {
  return config.outputTargets.some(
    (target) => target.type === WWW && (!!target.serviceWorker || !!target.baseUrl && target.baseUrl !== "/")
  );
}
function isUsingYarn(sys) {
  var _a;
  return ((_a = sys.getEnvironmentVar("npm_execpath")) == null ? void 0 : _a.includes("yarn")) || false;
}
function getActiveTargets(config) {
  const result = config.outputTargets.map((t) => t.type);
  return Array.from(new Set(result));
}
var prepareData = async (coreCompiler, config, sys, duration_ms, component_count = void 0) => {
  var _a, _b, _c;
  const { typescript, rollup } = coreCompiler.versions || { typescript: "unknown", rollup: "unknown" };
  const { packages, packagesNoVersions } = await getInstalledPackages(sys, config);
  const targets = getActiveTargets(config);
  const yarn = isUsingYarn(sys);
  const stencil = coreCompiler.version || "unknown";
  const system = `${sys.name} ${sys.version}`;
  const os_name = (_a = sys.details) == null ? void 0 : _a.platform;
  const os_version = (_b = sys.details) == null ? void 0 : _b.release;
  const cpu_model = (_c = sys.details) == null ? void 0 : _c.cpuModel;
  const build = coreCompiler.buildId || "unknown";
  const has_app_pwa_config = hasAppTarget(config);
  const anonymizedConfig = anonymizeConfigForTelemetry(config);
  return {
    arguments: config.flags.args,
    build,
    component_count,
    config: anonymizedConfig,
    cpu_model,
    duration_ms,
    has_app_pwa_config,
    os_name,
    os_version,
    packages,
    packages_no_versions: packagesNoVersions,
    rollup,
    stencil,
    system,
    system_major: getMajorVersion(system),
    targets,
    task: config.flags.task,
    typescript,
    yarn
  };
};
var OUTPUT_TARGET_KEYS_TO_KEEP = ["type"];
var CONFIG_PROPS_TO_ANONYMIZE = [
  "rootDir",
  "fsNamespace",
  "packageJsonFilePath",
  "namespace",
  "srcDir",
  "srcIndexHtml",
  "buildLogFilePath",
  "cacheDir",
  "configPath",
  "tsconfig"
];
var CONFIG_PROPS_TO_DELETE = [
  "commonjs",
  "devServer",
  "env",
  "logger",
  "rollupConfig",
  "sys",
  "testing",
  "tsCompilerOptions"
];
var anonymizeConfigForTelemetry = (config) => {
  const anonymizedConfig = { ...config };
  for (const prop of CONFIG_PROPS_TO_ANONYMIZE) {
    if (anonymizedConfig[prop] !== void 0) {
      anonymizedConfig[prop] = "omitted";
    }
  }
  anonymizedConfig.outputTargets = config.outputTargets.map((target) => {
    const anonymizedOT = JSON.parse(
      JSON.stringify(target, (key, value) => {
        if (!(typeof value === "string")) {
          return value;
        }
        if (OUTPUT_TARGET_KEYS_TO_KEEP.includes(key)) {
          return value;
        }
        return "omitted";
      })
    );
    if (isOutputTargetHydrate(target) && target.external) {
      anonymizedOT["external"] = target.external.concat();
    }
    return anonymizedOT;
  });
  for (const prop of CONFIG_PROPS_TO_DELETE) {
    delete anonymizedConfig[prop];
  }
  return anonymizedConfig;
};
async function getInstalledPackages(sys, config) {
  let packages = [];
  let packagesNoVersions = [];
  const yarn = isUsingYarn(sys);
  try {
    const appRootDir = sys.getCurrentDirectory();
    const packageJson = await tryFn(
      readJson,
      sys,
      sys.resolvePath(appRootDir + "/package.json")
    );
    if (!packageJson) {
      return { packages, packagesNoVersions };
    }
    const rawPackages = Object.entries({
      ...packageJson.devDependencies,
      ...packageJson.dependencies
    });
    const ionicPackages = rawPackages.filter(
      ([k]) => k.startsWith("@stencil/") || k.startsWith("@ionic/") || k.startsWith("@capacitor/")
    );
    try {
      packages = yarn ? await yarnPackages(sys, ionicPackages) : await npmPackages(sys, ionicPackages);
    } catch (e) {
      packages = ionicPackages.map(([k, v]) => `${k}@${v.replace("^", "")}`);
    }
    packagesNoVersions = ionicPackages.map(([k]) => `${k}`);
    return { packages, packagesNoVersions };
  } catch (err2) {
    hasDebug(config.flags) && console.error(err2);
    return { packages, packagesNoVersions };
  }
}
async function npmPackages(sys, ionicPackages) {
  const appRootDir = sys.getCurrentDirectory();
  const packageLockJson = await tryFn(readJson, sys, sys.resolvePath(appRootDir + "/package-lock.json"));
  return ionicPackages.map(([k, v]) => {
    var _a, _b, _c, _d;
    let version = (_d = (_c = (_a = packageLockJson == null ? void 0 : packageLockJson.dependencies[k]) == null ? void 0 : _a.version) != null ? _c : (_b = packageLockJson == null ? void 0 : packageLockJson.devDependencies[k]) == null ? void 0 : _b.version) != null ? _d : v;
    version = version.includes("file:") ? sanitizeDeclaredVersion(v) : version;
    return `${k}@${version}`;
  });
}
async function yarnPackages(sys, ionicPackages) {
  const appRootDir = sys.getCurrentDirectory();
  const yarnLock = sys.readFileSync(sys.resolvePath(appRootDir + "/yarn.lock"));
  const yarnLockYml = sys.parseYarnLockFile(yarnLock);
  return ionicPackages.map(([k, v]) => {
    var _a;
    const identifiedVersion = `${k}@${v}`;
    let version = (_a = yarnLockYml.object[identifiedVersion]) == null ? void 0 : _a.version;
    version = version.includes("undefined") ? sanitizeDeclaredVersion(identifiedVersion) : version;
    return `${k}@${version}`;
  });
}
function sanitizeDeclaredVersion(version) {
  return version.replace(/[*^~]/g, "");
}
async function sendMetric(sys, config, name, value) {
  const session_id = await getTelemetryToken(sys);
  const message = {
    name,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    source: "stencil_cli",
    value,
    session_id
  };
  await sendTelemetry(sys, config, message);
}
async function getTelemetryToken(sys) {
  const config = await readConfig(sys);
  if (config["tokens.telemetry"] === void 0) {
    config["tokens.telemetry"] = uuidv4();
    await writeConfig(sys, config);
  }
  return config["tokens.telemetry"];
}
async function sendTelemetry(sys, config, data) {
  try {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const body = {
      metrics: [data],
      sent_at: now
    };
    const response = await sys.fetch("https://api.ionicjs.com/events/metrics", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    hasVerbose(config.flags) && console.debug("\nSent %O metric to events service (status: %O)", data.name, response.status, "\n");
    if (response.status !== 204) {
      hasVerbose(config.flags) && console.debug("\nBad response from events service. Request body: %O", response.body.toString(), "\n");
    }
  } catch (e) {
    hasVerbose(config.flags) && console.debug("Telemetry request failed:", e);
  }
}
async function checkTelemetry(sys) {
  const config = await readConfig(sys);
  if (config["telemetry.stencil"] === void 0) {
    config["telemetry.stencil"] = true;
    await writeConfig(sys, config);
  }
  return config["telemetry.stencil"];
}
async function enableTelemetry(sys) {
  return await updateConfig(sys, { "telemetry.stencil": true });
}
async function disableTelemetry(sys) {
  return await updateConfig(sys, { "telemetry.stencil": false });
}
function getMajorVersion(version) {
  const parts = version.split(".");
  return parts[0];
}

// src/cli/task-build.ts
var taskBuild = async (coreCompiler, config) => {
  if (config.flags.watch) {
    await taskWatch(coreCompiler, config);
    return;
  }
  let exitCode = 0;
  try {
    startupCompilerLog(coreCompiler, config);
    const versionChecker = startCheckVersion(config, coreCompiler.version);
    const compiler = await coreCompiler.createCompiler(config);
    const results = await compiler.build();
    await telemetryBuildFinishedAction(config.sys, config, coreCompiler, results);
    await compiler.destroy();
    if (results.hasError) {
      exitCode = 1;
    } else if (config.flags.prerender) {
      const prerenderDiagnostics = await runPrerenderTask(
        coreCompiler,
        config,
        results.hydrateAppFilePath,
        results.componentGraph,
        null
      );
      config.logger.printDiagnostics(prerenderDiagnostics);
      if (prerenderDiagnostics.some((d) => d.level === "error")) {
        exitCode = 1;
      }
    }
    await printCheckVersionResults(versionChecker);
  } catch (e) {
    exitCode = 1;
    config.logger.error(e);
  }
  if (exitCode > 0) {
    return config.sys.exit(exitCode);
  }
};

// src/cli/task-docs.ts
var taskDocs = async (coreCompiler, config) => {
  config.devServer = {};
  config.outputTargets = config.outputTargets.filter(isOutputTargetDocs);
  config.devMode = true;
  startupCompilerLog(coreCompiler, config);
  const compiler = await coreCompiler.createCompiler(config);
  await compiler.build();
  await compiler.destroy();
};

// src/cli/task-generate.ts
var import_path2 = require("path");
var taskGenerate = async (config) => {
  if (!config.configPath) {
    config.logger.error("Please run this command in your root directory (i. e. the one containing stencil.config.ts).");
    return config.sys.exit(1);
  }
  const absoluteSrcDir = config.srcDir;
  if (!absoluteSrcDir) {
    config.logger.error(`Stencil's srcDir was not specified.`);
    return config.sys.exit(1);
  }
  const { prompt } = await import("../sys/node/prompts.js");
  const input = config.flags.unknownArgs.find((arg) => !arg.startsWith("-")) || (await prompt({ name: "tagName", type: "text", message: "Component tag name (dash-case):" })).tagName;
  if (void 0 === input) {
    return;
  }
  const { dir, base: componentName } = (0, import_path2.parse)(input);
  const tagError = validateComponentTag(componentName);
  if (tagError) {
    config.logger.error(tagError);
    return config.sys.exit(1);
  }
  const filesToGenerateExt = await chooseFilesToGenerate();
  if (void 0 === filesToGenerateExt) {
    return;
  }
  const extensionsToGenerate = ["tsx", ...filesToGenerateExt];
  const testFolder = extensionsToGenerate.some(isTest2) ? "test" : "";
  const outDir = (0, import_path2.join)(absoluteSrcDir, "components", dir, componentName);
  await config.sys.createDir(normalizePath((0, import_path2.join)(outDir, testFolder)), { recursive: true });
  const filesToGenerate = extensionsToGenerate.map((extension) => ({
    extension,
    path: getFilepathForFile(outDir, componentName, extension)
  }));
  await checkForOverwrite(filesToGenerate, config);
  const writtenFiles = await Promise.all(
    filesToGenerate.map(
      (file) => getBoilerplateAndWriteFile(config, componentName, extensionsToGenerate.includes("css"), file)
    )
  ).catch((error) => config.logger.error(error));
  if (!writtenFiles) {
    return config.sys.exit(1);
  }
  console.log();
  console.log(`${config.logger.gray("$")} stencil generate ${input}`);
  console.log();
  console.log(config.logger.bold("The following files have been generated:"));
  const absoluteRootDir = config.rootDir;
  writtenFiles.map((file) => console.log(`  - ${(0, import_path2.relative)(absoluteRootDir, file)}`));
};
var chooseFilesToGenerate = async () => {
  const { prompt } = await import("../sys/node/prompts.js");
  return (await prompt({
    name: "filesToGenerate",
    type: "multiselect",
    message: "Which additional files do you want to generate?",
    choices: [
      { value: "css", title: "Stylesheet (.css)", selected: true },
      { value: "spec.tsx", title: "Spec Test  (.spec.tsx)", selected: true },
      { value: "e2e.ts", title: "E2E Test (.e2e.ts)", selected: true }
    ]
  })).filesToGenerate;
};
var getFilepathForFile = (filePath, componentName, extension) => isTest2(extension) ? normalizePath((0, import_path2.join)(filePath, "test", `${componentName}.${extension}`)) : normalizePath((0, import_path2.join)(filePath, `${componentName}.${extension}`));
var getBoilerplateAndWriteFile = async (config, componentName, withCss, file) => {
  const boilerplate = getBoilerplateByExtension(componentName, file.extension, withCss);
  await config.sys.writeFile(normalizePath(file.path), boilerplate);
  return file.path;
};
var checkForOverwrite = async (files, config) => {
  const alreadyPresent = [];
  await Promise.all(
    files.map(async ({ path }) => {
      if (await config.sys.readFile(path) !== void 0) {
        alreadyPresent.push(path);
      }
    })
  );
  if (alreadyPresent.length > 0) {
    config.logger.error(
      "Generating code would overwrite the following files:",
      ...alreadyPresent.map((path) => "	" + normalizePath(path))
    );
    await config.sys.exit(1);
  }
};
var isTest2 = (extension) => {
  return extension === "e2e.ts" || extension === "spec.tsx";
};
var getBoilerplateByExtension = (tagName, extension, withCss) => {
  switch (extension) {
    case "tsx":
      return getComponentBoilerplate(tagName, withCss);
    case "css":
      return getStyleUrlBoilerplate();
    case "spec.tsx":
      return getSpecTestBoilerplate(tagName);
    case "e2e.ts":
      return getE2eTestBoilerplate(tagName);
    default:
      throw new Error(`Unkown extension "${extension}".`);
  }
};
var getComponentBoilerplate = (tagName, hasStyle) => {
  const decorator = [`{`];
  decorator.push(`  tag: '${tagName}',`);
  if (hasStyle) {
    decorator.push(`  styleUrl: '${tagName}.css',`);
  }
  decorator.push(`  shadow: true,`);
  decorator.push(`}`);
  return `import { Component, Host, h } from '@stencil/core';

@Component(${decorator.join("\n")})
export class ${toPascalCase(tagName)} {

  render() {
    return (
      <Host>
        <slot></slot>
      </Host>
    );
  }

}
`;
};
var getStyleUrlBoilerplate = () => `:host {
  display: block;
}
`;
var getSpecTestBoilerplate = (tagName) => `import { newSpecPage } from '@stencil/core/testing';
import { ${toPascalCase(tagName)} } from '../${tagName}';

describe('${tagName}', () => {
  it('renders', async () => {
    const page = await newSpecPage({
      components: [${toPascalCase(tagName)}],
      html: \`<${tagName}></${tagName}>\`,
    });
    expect(page.root).toEqualHtml(\`
      <${tagName}>
        <mock:shadow-root>
          <slot></slot>
        </mock:shadow-root>
      </${tagName}>
    \`);
  });
});
`;
var getE2eTestBoilerplate = (tagName) => `import { newE2EPage } from '@stencil/core/testing';

describe('${tagName}', () => {
  it('renders', async () => {
    const page = await newE2EPage();
    await page.setContent('<${tagName}></${tagName}>');

    const element = await page.find('${tagName}');
    expect(element).toHaveClass('hydrated');
  });
});
`;
var toPascalCase = (str) => str.split("-").reduce((res, part) => res + part[0].toUpperCase() + part.slice(1), "");

// src/cli/task-telemetry.ts
var taskTelemetry = async (flags, sys, logger) => {
  var _a;
  const prompt = logger.dim(((_a = sys.details) == null ? void 0 : _a.platform) === "windows" ? ">" : "$");
  const isEnabling = flags.args.includes("on");
  const isDisabling = flags.args.includes("off");
  const INFORMATION = `Opt in or out of telemetry. Information about the data we collect is available on our website: ${logger.bold(
    "https://stenciljs.com/telemetry"
  )}`;
  const THANK_YOU = `Thank you for helping to make Stencil better! \u{1F496}`;
  const ENABLED_MESSAGE = `${logger.green("Enabled")}. ${THANK_YOU}

`;
  const DISABLED_MESSAGE = `${logger.red("Disabled")}

`;
  const hasTelemetry = await checkTelemetry(sys);
  if (isEnabling) {
    const result = await enableTelemetry(sys);
    result ? console.log(`
  ${logger.bold("Telemetry is now ") + ENABLED_MESSAGE}`) : console.log(`Something went wrong when enabling Telemetry.`);
    return;
  }
  if (isDisabling) {
    const result = await disableTelemetry(sys);
    result ? console.log(`
  ${logger.bold("Telemetry is now ") + DISABLED_MESSAGE}`) : console.log(`Something went wrong when disabling Telemetry.`);
    return;
  }
  console.log(`  ${logger.bold("Telemetry:")} ${logger.dim(INFORMATION)}`);
  console.log(`
  ${logger.bold("Status")}: ${hasTelemetry ? ENABLED_MESSAGE : DISABLED_MESSAGE}`);
  console.log(`    ${prompt} ${logger.green("stencil telemetry [off|on]")}

        ${logger.cyan("off")} ${logger.dim(".............")} Disable sharing anonymous usage data
        ${logger.cyan("on")} ${logger.dim("..............")} Enable sharing anonymous usage data
  `);
};

// src/cli/task-help.ts
var taskHelp = async (flags, logger, sys) => {
  var _a;
  const prompt = logger.dim(((_a = sys.details) == null ? void 0 : _a.platform) === "windows" ? ">" : "$");
  console.log(`
  ${logger.bold("Build:")} ${logger.dim("Build components for development or production.")}

    ${prompt} ${logger.green("stencil build [--dev] [--watch] [--prerender] [--debug]")}

      ${logger.cyan("--dev")} ${logger.dim(".............")} Development build
      ${logger.cyan("--watch")} ${logger.dim("...........")} Rebuild when files update
      ${logger.cyan("--serve")} ${logger.dim("...........")} Start the dev-server
      ${logger.cyan("--prerender")} ${logger.dim(".......")} Prerender the application
      ${logger.cyan("--docs")} ${logger.dim("............")} Generate component readme.md docs
      ${logger.cyan("--config")} ${logger.dim("..........")} Set stencil config file
      ${logger.cyan("--stats")} ${logger.dim("...........")} Write stencil-stats.json file
      ${logger.cyan("--log")} ${logger.dim(".............")} Write stencil-build.log file
      ${logger.cyan("--debug")} ${logger.dim("...........")} Set the log level to debug


  ${logger.bold("Test:")} ${logger.dim("Run unit and end-to-end tests.")}

    ${prompt} ${logger.green("stencil test [--spec] [--e2e]")}

      ${logger.cyan("--spec")} ${logger.dim("............")} Run unit tests with Jest
      ${logger.cyan("--e2e")} ${logger.dim(".............")} Run e2e tests with Puppeteer


  ${logger.bold("Generate:")} ${logger.dim("Bootstrap components.")}

    ${prompt} ${logger.green("stencil generate")} or ${logger.green("stencil g")}

`);
  await taskTelemetry(flags, sys, logger);
  console.log(`
  ${logger.bold("Examples:")}

  ${prompt} ${logger.green("stencil build --dev --watch --serve")}
  ${prompt} ${logger.green("stencil build --prerender")}
  ${prompt} ${logger.green("stencil test --spec --e2e")}
  ${prompt} ${logger.green("stencil telemetry on")}
  ${prompt} ${logger.green("stencil generate")}
  ${prompt} ${logger.green("stencil g my-component")}
`);
};

// src/cli/task-info.ts
var taskInfo = (coreCompiler, sys, logger) => {
  const details = sys.details;
  const versions = coreCompiler.versions;
  console.log(``);
  console.log(`${logger.cyan("      System:")} ${sys.name} ${sys.version}`);
  if (details) {
    console.log(`${logger.cyan("    Platform:")} ${details.platform} (${details.release})`);
    console.log(
      `${logger.cyan("   CPU Model:")} ${details.cpuModel} (${sys.hardwareConcurrency} cpu${sys.hardwareConcurrency !== 1 ? "s" : ""})`
    );
  }
  console.log(`${logger.cyan("    Compiler:")} ${sys.getCompilerExecutingPath()}`);
  console.log(`${logger.cyan("       Build:")} ${coreCompiler.buildId}`);
  console.log(`${logger.cyan("     Stencil:")} ${coreCompiler.version}${logger.emoji(" " + coreCompiler.vermoji)}`);
  console.log(`${logger.cyan("  TypeScript:")} ${versions.typescript}`);
  console.log(`${logger.cyan("      Rollup:")} ${versions.rollup}`);
  console.log(`${logger.cyan("      Parse5:")} ${versions.parse5}`);
  console.log(`${logger.cyan("      jQuery:")} ${versions.jquery}`);
  console.log(`${logger.cyan("      Terser:")} ${versions.terser}`);
  console.log(``);
};

// src/cli/task-serve.ts
var taskServe = async (config) => {
  config.suppressLogs = true;
  config.flags.serve = true;
  config.devServer.openBrowser = !!config.flags.open;
  config.devServer.reloadStrategy = null;
  config.devServer.initialLoadUrl = "/";
  config.devServer.websocket = false;
  config.maxConcurrentWorkers = 1;
  config.devServer.root = isString(config.flags.root) ? config.flags.root : config.sys.getCurrentDirectory();
  const devServerPath = config.sys.getDevServerExecutingPath();
  const { start } = await config.sys.dynamicImport(devServerPath);
  const devServer = await start(config.devServer, config.logger);
  console.log(`${config.logger.cyan("     Root:")} ${devServer.root}`);
  console.log(`${config.logger.cyan("  Address:")} ${devServer.address}`);
  console.log(`${config.logger.cyan("     Port:")} ${devServer.port}`);
  console.log(`${config.logger.cyan("   Server:")} ${devServer.browserUrl}`);
  console.log(``);
  config.sys.onProcessInterrupt(() => {
    if (devServer) {
      config.logger.debug(`dev server close: ${devServer.browserUrl}`);
      devServer.close();
    }
  });
};

// src/cli/task-test.ts
var taskTest = async (config) => {
  config.buildDocs = false;
  const testingRunOpts = {
    e2e: !!config.flags.e2e,
    screenshot: !!config.flags.screenshot,
    spec: !!config.flags.spec,
    updateScreenshot: !!config.flags.updateScreenshot
  };
  const ensureModuleIds = ["@types/jest", "jest", "jest-cli"];
  if (testingRunOpts.e2e) {
    const puppeteer = config.testing.browserExecutablePath ? "puppeteer-core" : "puppeteer";
    ensureModuleIds.push(puppeteer);
    if (testingRunOpts.screenshot) {
      config.logger.warn(
        config.logger.yellow(
          `EXPERIMENTAL: screenshot visual diff testing is currently under heavy development and has not reached a stable status. However, any assistance testing would be appreciated.`
        )
      );
    }
  }
  const diagnostics = await config.sys.lazyRequire.ensure(config.rootDir, ensureModuleIds);
  if (diagnostics.length > 0) {
    config.logger.printDiagnostics(diagnostics);
    return config.sys.exit(1);
  }
  try {
    const { createTesting } = await import("../testing/index.js");
    const testing = await createTesting(config);
    const passed = await testing.run(testingRunOpts);
    await testing.destroy();
    if (!passed) {
      return config.sys.exit(1);
    }
  } catch (e) {
    config.logger.error(e);
    return config.sys.exit(1);
  }
};

// src/cli/run.ts
var run = async (init) => {
  const { args, logger, sys } = init;
  try {
    const flags = parseFlags(args);
    const task = flags.task;
    if (flags.debug || flags.verbose) {
      logger.setLevel("debug");
    }
    if (flags.ci) {
      logger.enableColors(false);
    }
    if (isFunction(sys.applyGlobalPatch)) {
      sys.applyGlobalPatch(sys.getCurrentDirectory());
    }
    if (task && task === "version" || flags.version) {
      const coreCompiler2 = await loadCoreCompiler(sys);
      console.log(coreCompiler2.version);
      return;
    }
    if (!task || task === "help" || flags.help) {
      await taskHelp(createConfigFlags({ task: "help", args }), logger, sys);
      return;
    }
    startupLog(logger, task);
    const findConfigResults = await findConfig({ sys, configPath: flags.config });
    if (findConfigResults.isErr) {
      logger.printDiagnostics(findConfigResults.value);
      return sys.exit(1);
    }
    const coreCompiler = await loadCoreCompiler(sys);
    startupLogVersion(logger, task, coreCompiler);
    loadedCompilerLog(sys, logger, flags, coreCompiler);
    if (task === "info") {
      taskInfo(coreCompiler, sys, logger);
      return;
    }
    const foundConfig = result_exports.unwrap(findConfigResults);
    const validated = await coreCompiler.loadConfig({
      config: {
        flags
      },
      configPath: foundConfig.configPath,
      logger,
      sys
    });
    if (validated.diagnostics.length > 0) {
      logger.printDiagnostics(validated.diagnostics);
      if (hasError(validated.diagnostics)) {
        return sys.exit(1);
      }
    }
    if (isFunction(sys.applyGlobalPatch)) {
      sys.applyGlobalPatch(validated.config.rootDir);
    }
    await telemetryAction(sys, validated.config, coreCompiler, async () => {
      await runTask(coreCompiler, validated.config, task, sys);
    });
  } catch (e) {
    if (!shouldIgnoreError(e)) {
      const details = `${logger.getLevel() === "debug" && e instanceof Error ? e.stack : ""}`;
      logger.error(`uncaught cli error: ${e}${details}`);
      return sys.exit(1);
    }
  }
};
var runTask = async (coreCompiler, config, task, sys) => {
  var _a;
  const flags = createConfigFlags((_a = config.flags) != null ? _a : { task });
  config.flags = flags;
  if (!config.sys) {
    config.sys = sys;
  }
  const strictConfig = coreCompiler.validateConfig(config, {}).config;
  switch (task) {
    case "build":
      await taskBuild(coreCompiler, strictConfig);
      break;
    case "docs":
      await taskDocs(coreCompiler, strictConfig);
      break;
    case "generate":
    case "g":
      await taskGenerate(strictConfig);
      break;
    case "help":
      await taskHelp(strictConfig.flags, strictConfig.logger, sys);
      break;
    case "prerender":
      await taskPrerender(coreCompiler, strictConfig);
      break;
    case "serve":
      await taskServe(strictConfig);
      break;
    case "telemetry":
      await taskTelemetry(strictConfig.flags, sys, strictConfig.logger);
      break;
    case "test":
      await taskTest(strictConfig);
      break;
    case "version":
      console.log(coreCompiler.version);
      break;
    default:
      strictConfig.logger.error(
        `${strictConfig.logger.emoji("\u274C ")}Invalid stencil command, please see the options below:`
      );
      await taskHelp(strictConfig.flags, strictConfig.logger, sys);
      return config.sys.exit(1);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BOOLEAN_CLI_FLAGS,
  parseFlags,
  run,
  runTask
});
